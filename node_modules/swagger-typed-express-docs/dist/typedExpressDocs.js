"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.initApiDocs = exports.apiDoc = exports.__expressSwaggerHack__ = exports.__expressSwaggerHack_key__ = void 0;
var utils_1 = require("./utils");
var schemaBuilder_1 = require("./schemaBuilder");
var swaggerFromSchema_1 = require("./swaggerFromSchema");
var runtimeSchemaValidation_1 = require("./runtimeSchemaValidation");
var expressRegExUrlParser_1 = require("./expressRegExUrlParser");
exports.__expressSwaggerHack_key__ = '__expressSwaggerHack_key__';
exports.__expressSwaggerHack__ = Symbol('__expressSwaggerHack__');
var convertYupErrToObj = function (obj) { return JSON.parse(JSON.stringify(obj)); };
var apiDoc = function (docs) { return function (handle) {
    var paramsSchema = docs.params ? schemaBuilder_1.tNonNullable(schemaBuilder_1.tObject(docs.params)) : null;
    var querySchema = docs.query ? schemaBuilder_1.tNonNullable(schemaBuilder_1.tObject(docs.query)) : null;
    var bodySchema = docs.body ? schemaBuilder_1.tNonNullable(schemaBuilder_1.tObject(docs.body)) : null;
    var paramsValidator = paramsSchema ? runtimeSchemaValidation_1.convertSchemaToYupValidationObject(paramsSchema) : null;
    var queryValidator = querySchema ? runtimeSchemaValidation_1.convertSchemaToYupValidationObject(querySchema) : null;
    var bodyValidator = bodySchema ? runtimeSchemaValidation_1.convertSchemaToYupValidationObject(bodySchema) : null;
    var lazyInitializeHandler = function (message) {
        if (message !== exports.__expressSwaggerHack__) {
            throw new Error('You probably forget to call `initApiDocs()` for typed-express library');
        }
        var handleRouteWithRuntimeValidations = function (req, res, next) {
            var _a = __read(utils_1.syncAllSettled([
                function () { return paramsValidator === null || paramsValidator === void 0 ? void 0 : paramsValidator.validateSync(req.params, { abortEarly: false }); },
                function () { return queryValidator === null || queryValidator === void 0 ? void 0 : queryValidator.validateSync(req.query, { abortEarly: false }); },
                function () { return bodyValidator === null || bodyValidator === void 0 ? void 0 : bodyValidator.validateSync(req.body, { abortEarly: false }); },
            ]), 3), urlValidation = _a[0], queryValidation = _a[1], bodyValidation = _a[2];
            if (urlValidation.status === 'rejected' ||
                queryValidation.status === 'rejected' ||
                bodyValidation.status === 'rejected') {
                var paramsErrors = urlValidation.status === 'rejected' ? urlValidation.reason : null;
                var queryErrors = queryValidation.status === 'rejected' ? queryValidation.reason : null;
                var bodyErrors = bodyValidation.status === 'rejected' ? bodyValidation.reason : null;
                var errObj = {
                    errors: {
                        paramsErrors: convertYupErrToObj(paramsErrors),
                        queryErrors: convertYupErrToObj(queryErrors),
                        bodyErrors: convertYupErrToObj(bodyErrors),
                    },
                };
                res.status(400).send(errObj);
                return;
            }
            return handle(req, res, next);
        };
        return {
            apiRouteSchema: {
                paramsSchema: paramsSchema,
                querySchema: querySchema,
                bodySchema: bodySchema,
                returnsSchema: docs.returns,
            },
            handle: handleRouteWithRuntimeValidations,
        };
    };
    lazyInitializeHandler[exports.__expressSwaggerHack_key__] = exports.__expressSwaggerHack__;
    return lazyInitializeHandler;
}; };
exports.apiDoc = apiDoc;
var resolveRouteHandlersAndExtractAPISchema = function (route, path, urlsMethodDocs) {
    if (path === void 0) { path = ''; }
    if (urlsMethodDocs === void 0) { urlsMethodDocs = {}; }
    route.stack
        .filter(function (s) { return s.name === 'router'; })
        .forEach(function (s) {
        var _a, _b;
        var stack = s;
        var parsedRouterRelativePath = expressRegExUrlParser_1.parseUrlFromExpressRegexp(stack.regexp.toString(), (_a = stack.keys) !== null && _a !== void 0 ? _a : []);
        var routerFullPath = utils_1.mergePaths(path, parsedRouterRelativePath);
        resolveRouteHandlersAndExtractAPISchema((_b = stack.handle) !== null && _b !== void 0 ? _b : stack.__handle, routerFullPath, urlsMethodDocs);
    });
    route.stack
        .filter(function (s) { return s.name === 'bound dispatch'; })
        .map(function (s) { return s.route; })
        .forEach(function (r) {
        r.stack.forEach(function (s) {
            var _a;
            if (((_a = s.handle) === null || _a === void 0 ? void 0 : _a[exports.__expressSwaggerHack_key__]) !== exports.__expressSwaggerHack__)
                return;
            var routeMetadataDocs = s.handle(exports.__expressSwaggerHack__);
            var endpointPath = utils_1.mergePaths(path, r.path);
            if (!urlsMethodDocs[endpointPath]) {
                urlsMethodDocs[endpointPath] = {};
            }
            urlsMethodDocs[endpointPath][s.method] = {
                pathSchema: routeMetadataDocs.apiRouteSchema.paramsSchema,
                querySchema: routeMetadataDocs.apiRouteSchema.querySchema,
                bodySchema: routeMetadataDocs.apiRouteSchema.bodySchema,
                returnsSchema: routeMetadataDocs.apiRouteSchema.returnsSchema,
            };
            s.handle = routeMetadataDocs.handle;
        });
    });
    return urlsMethodDocs;
};
var initApiDocs = function (expressApp, customSwaggerType) {
    if (customSwaggerType === void 0) { customSwaggerType = {}; }
    return utils_1.deepMerge({
        swagger: '2.0',
        info: {
            title: 'Swagger documentation',
            termsOfService: 'http://swagger.io/terms/',
        },
        schemes: ['https', 'http'],
        paths: swaggerFromSchema_1.convertUrlsMethodsSchemaToSwagger(resolveRouteHandlersAndExtractAPISchema(expressApp._router)),
    }, customSwaggerType);
};
exports.initApiDocs = initApiDocs;
