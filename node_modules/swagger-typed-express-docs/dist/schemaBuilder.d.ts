declare type NiceMerge<T, U, T0 = T & U, T1 = {
    [K in keyof T0]: T0[K];
}> = T1;
declare type DeepWriteable<T> = {
    -readonly [P in keyof T]: DeepWriteable<T[P]>;
};
export declare type SchemaList = {
    type: 'array';
    required: boolean;
    items: Schema;
};
export declare type SchemaObject = {
    type: 'object';
    required: boolean;
    properties: Record<string, Schema>;
};
export declare type SchemaBoolean = {
    type: 'boolean';
    required: boolean;
};
export declare type SchemaString = {
    type: 'string';
    required: boolean;
};
export declare type SchemaNumber = {
    type: 'number';
    required: boolean;
};
export declare type SchemaCustomScalar = {
    name: string;
    type: 'customScalar';
    parser: (val: any) => any;
    validator: (val: any) => any;
    required: boolean;
};
export declare type SchemaAny = {
    type: 'any';
    required: boolean;
};
export declare type SchemaEnum = {
    type: 'enum';
    required: boolean;
    options: any[];
};
export declare type Schema = SchemaList | SchemaObject | SchemaString | SchemaNumber | SchemaBoolean | SchemaAny | SchemaEnum | SchemaCustomScalar;
export declare const tNumber: {
    type: "number";
    required: false;
};
export declare const tBoolean: {
    type: "boolean";
    required: false;
};
export declare const tString: {
    type: "string";
    required: false;
};
export declare const tAny: {
    type: "any";
    required: false;
};
export declare const tUnion: <T extends any[] | readonly any[]>(options: T) => {
    type: "enum";
    required: false;
    options: DeepWriteable<T>;
};
export declare const tObject: <T>(a: T) => {
    type: "object";
    required: false;
    properties: T;
};
export declare const tList: <T extends Schema>(items: T) => {
    type: "array";
    required: boolean;
    items: T;
};
export declare const tCustomScalar: <R>(name: string, conf: {
    parser: (v: any) => R;
    validator: (v: any) => boolean;
}) => {
    name: string;
    type: "customScalar";
    required: boolean;
    parser: (v: any) => R;
    validator: (v: any) => boolean;
};
export declare const tNonNullable: <T extends {
    required: any;
}>(a: T) => { [K in keyof (Omit<T, "required"> & {
    required: true;
})]: (Omit<T, "required"> & {
    required: true;
})[K]; };
export {};
